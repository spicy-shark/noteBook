# Redis（重点）

## zset实现原理，为什么是跳表，为什么不用红黑树

https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247512204&idx=4&sn=8a2a24e139f1c5fdfcc0f017b280bd0e&chksm=fbb13972ccc6b0647387c63c87acb6f638ce8c99dca30d958a4e91ed766224f50a32ec7281ad&scene=27

跳表结构

https://blog.csdn.net/weichi7549/article/details/107335133/

构建跳表短源码分析

## Redis字典如何实现

## 主从结构的Redis分布式锁

红锁（RedLock）机制

Redission锁续期

## 布隆过滤器原理

https://blog.csdn.net/qq_55624813/article/details/121316520

## 过期策略

https://blog.csdn.net/luciferlongxu/article/details/119190895

定期删除+惰性删除，定期删除是指每隔一段时间（100ms）在设置了过期时间的key中选择一些检查其过期时间并删除，惰性删除是指，当查询该数据时发现已经过期则删除。

如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，这时则使用内存淘汰机制（LRU算法）

## 持久化

RDB和AOF

RDB通过快照的方式宕机后可以快速恢复，可以使用此方式同步数据（主从结构），是默认的持久化方式。

AOF持久化拥有更好的实时性，已成为主流的持久化方式，开启AOF持久化后每执行一条会修改Redis数据的命令，Redis都会将该命令写入内存缓存中然后根据配置来决定何时将其同步到磁盘中的AOF文件，一般建议设置每秒同步一次，几乎不会对Redis的性能产生影响

## 几种部署结构（高可用）

主从模式和哨兵模式应用场景

## 缓存穿透击穿和雪崩

**缓存穿透：** 大量的key不合理，既不在Redis也不存在于数据库，大量不合理的请求直接到数据库上造成很大压力。

解决方式：

* 参数校验
* 布隆过滤器

**缓存击穿：** 热点key未存在于缓存，导致大量请求直接到达数据库，造成很大压力。

解决方式：

* 通过加互斥锁来解决，请求未命中缓存则加锁，知道该请求将数据读取并写入缓存后下一个请求再直接读取缓存
* 将热点key设置成不过期或者过期时间较长

**缓存雪崩：** 大量key同时过期导致请求直接到达数据库。

解决办法：

* 将key的过期时间设置成不同，避免同时大量过期
* 二级缓存
* 采用集群模式，保证高可用
* 限流，避免同时出现大量请求

## Redis单线程模型，为什么快

## 不使用锁，改造HashMap使其线程安全（提示Redis中的Hash原理）

Redis哈希原理：https://blog.csdn.net/swl1993831/article/details/124559419

使用版本号机制每进行一次写操作， 则版本号自增，仅当前版本号与缓存一致时才进行写操作

# RabbitMQ

## Kafka可以了解一下

## 容灾机制&持久化&可靠性

1. 持久化：将队列、交换机和消息持久化，持久化会将消息写入日志中，以便重启时恢复，但是持久化会导致十倍以上的性能下降。
2. 事务性（confirm机制）：在配置了confirm的信道上发布的消息会包含一个唯一消息ID，在被正确接收和持久化之后，MQ会异步返回一个包含该唯一ID的ACK，同样，MQ发生内部错误导致消息接收失败也会返回一个NACK。

# 数据库

## SQL语句

## 数据库隔离级别

* 脏读：事务B读取事务A未提交的内容，如果事务A回滚则会读取到脏数据。
* 不可重复读：事务B读取数据后，事务A将数据修改，事务B再次读取会读到不同结果。
* 幻读：事务B进行范围查询，然后事务A对数据进行插入操作，事务B再次读取会发现读取内容比上一次多，好像产生幻觉。

不可重复读和幻读两者有些相似。但 `不可重复读重点在于update和delete，而幻读的重点在于insert。`

1. 读未提交：事务B可以读取到事务A未提交的数据，会出现脏读、不可重复读、幻读的问题。
2. 读已提交：事务B不可读取事务A未提交的数据，可以解决脏读的问题，但是会出现不可重复读和幻读的问题。
3. 可重复读：事务B读取数据时对该数据加锁禁止其他事物的写操作，保证前后读取结果一致，但是会出现幻读的问题。
4. 串行化：指令串行执行可以解决全部问题，但是性能非常低。

大多数数据库的默认隔离级别是读已提交，MySQL的InnoDB的默认隔离级别是可重复读

### ACID和CAP理论

ACID：原子性，一致性，隔离性，持久性

CAP理论：https://blog.csdn.net/lihuarongaini/article/details/101298108

### MySQL的锁

https://blog.csdn.net/be_racle/article/details/126566613

#### 锁粒度

* 表级锁：是最大粒度的锁，实现逻辑最简单且不会出现死锁，加锁和释放速度快对系统影响最小，但是性能较差。
* 行级锁：粒度很小，所以资源竞争最小，适合高并发场景， 但是由于粒度最小，加锁和释放时需要做的事情很多，带来的消耗自然会变大，同时行级锁也最容易发生死锁。
* 页级锁：是MySQL中比较特别的一种锁，它的锁定粒度、加锁和释放带来的资源开销、以及并发处理能力，都介于以上两者之间，也会发生死锁。

### 间隙锁的作用

间隙锁是MySQL为了解决幻读问题引入的锁机制，是行锁的一种，使用间隙锁锁住的是一个区间而不仅仅是这个区间的每一条数据。

## B+树

### B+树索引和哈希索引的区别

### 为什么不用二叉树而用B+树，为什么不用红黑树

B+树层数低，一个B+树可以存储一个页（16kb）的数据，一般类型数据只需要2～3层索引即可索引到2000w左右级别的数据，便于范围查询和遍历，

哈希索引单个查询效率非常高，而且适合长字符串的查询，例如url的存储可以将url生成一个crc再进行哈希。但是哈希索引的问题是插入和更新很慢，每次都要重新维护索引，而且如果建立了不恰当的索引也会导致性能降低。

**B+树的数据级别：**

**先计算非页节点：**

非叶节点不保存数据，只保存主键值和指向子节点的指针。

指针在InnoDB中为6字节，假数据库主键的类型是bigint，占8字节。那么一个非叶节点能保存的数据量为16 * 1024 / 14 = 1170(个)主键和指针对。第二层的存储的数量就是1170*1170=1368900个主键和指针对。

**再计算叶子节点存储多少数据：**

假设数据的大小为1KB，那么一个叶子节点可以存储16条数据（忽略指针大小）。

**最后三层B+树可以存储多少数据？**

结果为1368900 x 16 = 21902400条数据，即1170 x 1170 x 16 = 21902400。

## 索引类型

### 数据稀疏度对索引效率的影响

稠密索引：没个索引都对应一条数据，检索速度快，索引到即定位到数据，插入和删除时维护索引开销大。

稀疏索引：对一块数据维护索引，索引到后在数据块内线性检索数据，查询速度较慢，但是索引的维护较为简单。

### 如何判断查询语句是否走索引、索引失效的情况

使用 `EXPLAIN`来进行分析，使用该命令并不会真正的去执行查询语句，而是通过“查询优化器"对查询语句分析，找出最优查询方案，显示相关信息。

索引失效：

1. 使用 `SELECT *`进行查询；
2. 创建联合索引但是未遵循最左匹配原则；
3. 在索引列上进行计算、函数、类型转换等操作；
4. 使用 `%`开头的 `like`查询比如 `LIKE %abc`；
5. 查询中使用 `or`，但是 `or`前后的列没有全部都加索引，会导致涉及的所有列的索引都失效；
6. 发生隐式转换
7. ······

### 主键自增为什么比随机和自定义的快

https://blog.csdn.net/m0_37383866/article/details/88100808

新增记录时，如果是自增记录就会顺序添加到当前索引节点的后面，当页写满后再开辟一个新的页，如果是随机或者自定义则每次插入都需要调整主键索引，并且需要移动数据，增加很多非必要的开销。

## MVCC

https://zhuanlan.zhihu.com/p/421769708

## 优化

### 慢查询优化

https://blog.csdn.net/jj89929665/article/details/125199904

https://www.jb51.net/article/269776.htm

### SQL语句统计一天中看视频次数前五的用户，扩展到同一个视频不算

## Redis和数据库如何保证数据一致性（同步性）

# 网络

https://zhuanlan.zhihu.com/p/573020210

## 浏览器输入网址回车后发生了什么

https://blog.csdn.net/jiao_0509/article/details/82491299?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82491299-blog-123423838.235%5Ev27%5Epc_relevant_default_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82491299-blog-123423838.235%5Ev27%5Epc_relevant_default_base1

1. DNS解析域名
2. 根据IP端口和服务器建立连接（HTTP/HTTPS）-三次握手
3. 数据传输结束后断开连接-四次挥手
4. 客户端解析响应数据并展示

## PUT和POST的区别

## HTTP状态码

## HTTP1.0、1.1、2.0的区别、每个版本的弊端以及如何解决

https://blog.csdn.net/weixin_45910068/article/details/126290248

https://blog.csdn.net/weixin_47826078/article/details/127960493

https://blog.csdn.net/qq_34272760/article/details/126398841?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-126398841-blog-127960493.235%5Ev27%5Epc_relevant_default_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-126398841-blog-127960493.235%5Ev27%5Epc_relevant_default_base1&utm_relevant_index=1

HTTP1.0：无状态、无连接，一次连接只能处理一个请求。队头阻塞，下一个请求必须在前一个请求到达之后发送。

HTTP1.1：长连接，一个连接可以处理多个请求。管道化，请求可以并行，但是服务端必须按顺序返回客户端的请求，无法解决队头阻塞的问题，相当于把客户端的请求队列放到了服务端。支持断点续传。但是HTTP1.1依然是无状态的。

HTTP2.0：HTTP1.x是基于文本的，而HTTP2.0使用二进制进行编码，具有更好的健壮性。多路复用实现并发，数据流还支持优先级和流量控制（类似TCP的滑动窗口）支持服务端推送。但是由于HTTP2.0基于TCP协议，TCP协议必须将数据报全部确认才会将数据交由上层，所以还是存在队头阻塞问题。

HTTP3.0：使用QUIC协议来解决队头阻塞的问题，基于UDP协议，各个请求Stream之间不存在依赖关系，某个流丢包只会影响当前流不会影响其他请求。

https://blog.csdn.net/weixin_45910068/article/details/126290248

## HTTPS具体流程 HTTP3.0

CA信任链

## HTTP连接和TCP连接的区别

https://blog.csdn.net/weixin_48956280/article/details/119865934

HTTP基于TCP，HTTP是请求-响应模式，服务端被动响应，而TCP可以双方互发消息。

## OSI七层模型、TCP/IP四层模型

## 网络层和传输层常见协议

## TCP/UDP区别

## TCP拥塞控制，UDP是否需要拥塞控制

## TCP黏包问题如何解决

https://blog.csdn.net/fighterandknight/article/details/121436430

## TCP如何保证可靠性

序列号确认机制

差错校验（校验和）

拥塞控制

滑动窗口机制

## 三次握手四次挥手、三次握手是否可以两次

## TCP滑动窗口、拥塞控制

接收窗口大还是发送窗口大

# JVM

## JVM调优

## 垃圾回收器

https://pdai.tech/md/java/jvm/java-jvm-gc.html

逃逸分析

TLAB

CMS

G1

## 内存模型

### static修饰的变量放在哪里

### 如何确认以及定位内存泄漏

https://www.cnblogs.com/csnjava/p/16489707.html

## 垃圾回收机制为什么要分新生代和老年代，如何证明新生代生命周期比较短

## 有没有办法降低垃圾回收对性能的影响?

讲了Java1.8其他垃圾回收器，CMS和G1的工作原理

## OOM如何排查

有哪些JVM查看堆和栈道工具，jps和jmap之类的

## 如何修改堆大小和栈大小

# Java

## IO

### IO多路复用的实现

## JAVA 反射原理 接口和抽象类使用场景泛型和泛型擦除

## servlet

https://blog.csdn.net/m0_67296957/article/details/127453695

## Map的衍生结构、TreeMap原理和使用场景、HashTable、ConcurrentHashMap

## ArrayList和HashMap扩容机制，以及扩容过程中需要注意哪些问题

## 类加载、双亲委派机制（重点）

**站在Java开发人员的角度来看，类加载器可以大致划分为以下三类** :

`启动类加载器`: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。

`扩展类加载器`: Extension ClassLoader，该加载器由 `sun.misc.Launcher$ExtClassLoader`实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。

`应用程序类加载器`: Application ClassLoader，该类加载器由 `sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

---

著作权归@pdai所有
原文链接：https://pdai.tech/md/java/jvm/java-jvm-classload.html

自己实现一个 `lang.String`类，能否调用成功，类的双亲委派机制

https://zhuanlan.zhihu.com/p/94297366

类加载机制如何比较，getClass

https://www.cnblogs.com/kakaisgood/p/14888056.html

**双亲委派机制过程？**

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

---

著作权归@pdai所有
原文链接：https://pdai.tech/md/java/jvm/java-jvm-classload.html

## 内部类和匿名内部类

## 设计模式

### 单例模式、工厂模式、策略模式

### 建造者模式

### 订阅者模式、观察者模式

https://blog.csdn.net/qq_41824825/category_11508289.html

## 字符串加法运算符的原理，为什么不推荐在循环中使用加号拼接字符串

## 强引用、弱引用、软引用、虚引用

## 值传递和引用传递

## ThreadLocal原理

## 多线程

### sleep()和wait()的区别

### 线程池的作用、线程池参数、拒绝策略和等待类型之间的关系

IO密集型和CPU密集型如何设置最大和核心线程

### 多个线程从一个队列中取任务时如何尽可能避免竞争

### 若线程池要按时间顺序执行线程，现依次往线程池里提交多个任务并要求他们在给定时间执行，请问如何高效地保证这些线程按顺序执行?

### CAS的原子性如何保证，如何解决ABA问题

### 几种锁（乐观锁悲观锁可重入锁自旋锁等等）

https://blog.csdn.net/xx12321q/article/details/124925441

### synchronized原理、ReentrantLock原理以及源码分析

1.8对synchorized的优化

公平锁的原理

### volatile作用、多线程的volatile实现原理

### JMM模型以及内存屏障

# 计算机基础

## 进程间通信的几种方式

# 项目

## 对称加密和非对称加密以及其在HTTPS中的作用

常见对称加密和非对称加密算法

## JWT有哪三部分

头部、载荷、签名

## 服务降级和熔断

## 服务器给一批IP开白名单、一批IP开黑名单

## 单一业务ID算法

## RPC框架

# Spring

## IOC和AOP，IOC在整个Spring框架中起到了什么作用

## Spring代理有哪些，实现思想

# 系统设计题

设计一个短连接生成系统，要求把长url变成短url

https://www.cnblogs.com/lingyejun/p/15894620.html

# 操作系统

## 操作系统的缺页中断概念，中断内发生了什么事

## 进程的上下文切换需要保存哪些东西

## 进程有哪些数据段，线程可以使用哪些进程的数据段

## CPU在执行一个线程的时候什么情况下会被切换走

## 零拷贝原理

## 同步IO和异步IO，阻塞IO和非阻塞IO

# 算法

* [ ] 水库抽样
* [ ] 堆排序
* [ ] 手写算法判断一个IP地址是否正确
* [ ] 写一个死锁案例
* [ ] LRU算法
* [ ] 最大连续子序列和和回文链表
* [ ] 一个奇数位升序、偶数位降序的单向无环链表，排成一个有序链表
* [ ] S型打印二叉树，两条单向链表的相交节点，任意数组中的第一个缺失的正整数
* [ ] 一致性哈希
* [ ] 牛顿迭代求平方根
* [ ] leetcode.76 最小覆盖子串
* [ ] leetcode.107 二叉树的层序遍历 直接默写。不过要自己构建一颗二叉树来做测试用例。
* [ ] 货币兑换总方案数
* [ ] LeetCode解码方法
* [ ] 前序中序重建二叉树
* [ ] LeetCode321
* [ ] LeetCode打家劫舍
* [ ] LeetCode230
* [ ] LeetCode445
* [ ] LeetCode394字符串解码
* [ ] LeetCode34
* [X] K个一组反转链表
* [X] https://leetcode.cn/problems/2VG8Kg/?favorite=e8X3pBZi

# 场景题

1. 考虑一个场景，如何统计抖音活跃用户，说一下思路，你可能用到的数据结构?
2. 如果 MySQL 中有 10 亿条数据
   * 怎么查询的?B+ 树上又是如何查询的?
   * 自适应哈希对这种情况适用吗?
   * 统计 10 亿条数据中最活跃的前 5 名，如何做?
   * 10 亿条数据分库分表，怎么做?对那个字段分?
   * 查询 TOP K 的 SQL
