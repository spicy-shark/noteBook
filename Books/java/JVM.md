# JVM

## Java内存区域详解

线程私有的：

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的：

- 堆
- 方法区
- 直接内存（非运行数据区的一部分）

### 程序计数器

程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### Java虚拟机栈

栈由一个个栈帧组成，每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

**局部变量表：**主要存放了编译期可知的各种数据类型、对象引用（reference类型）。

**操作数栈：**用于存放方法执行过程的产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接：**主要服务一个方法需要调用其他方法的场景。在Java源文件被编译成字节码文件时，所有变量和方法引用都作为符号引用（Symbilic Reference）保存在class文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存中的直接引用。动态链接的作用就是为了将符号引用转化为调用方法的直接引用。

栈运行中可能会出现两种错误：

- StackOverFlowError：若栈的大小不允许动态扩展，那么当前线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverflowError。
- OutOfMemoryError：如果栈的大小可以扩展，如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。

### [本地方法栈](https://blog.csdn.net/Alice_whj/article/details/123294358)

虚拟机栈为执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出战并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种错误。
